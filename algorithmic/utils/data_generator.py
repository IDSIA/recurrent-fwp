# Code to generate the data set for Python code execution task.
#
# Sketch:
# For a given code length,
# 0: `assign`, randomly choose one of the variables.
#    Randomly choose a number between 1 and 10, and assign.
#    The first operation is necessarily this one.
# 1: `increment/decrement`, randomly choose between increment/decrement.
#    Randomly choose one of the defined variables and apply.
# 2: `print`, randomly choose a defined variable.
# 3: `conditional`, randomly choose a cond variable between existing ones.
#    Randomly choose between greater/less.
#    Randomly choose an operation not-conditional, apply the op.
#
# Description in Fan et al.:
#
# '''
# A program is generated by randomly choosing a statement one after another,
# but with the following conditions: a variable must be initialized before
# being used, and a variable value have to between 1 and 10.
# The training data contains 10k such programs concatenated with a special
# separator keyword. We generate two version the data with 3 and 5 different
# variables in them.
# '''

import sys
from random import randrange as drw
import random


# Problem setting:
num_ops = 4

# Task hyper-parameters
rnd_seed = 42
random.seed(rnd_seed)

max_num_vars = 3  # 3 or 5
max_assign_value = 10  # max value for assign op.
max_cond_value = 10

# Operations which result in value outside this range are rejected.
# Relevant for increment/decrement statement.
max_allowed_val = 16
min_allowed_val = -8

no_op_token = '_'
full_var_idx_to_str = ['x', 'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g']
var_idx_to_str = full_var_idx_to_str[:max_num_vars]
cond_idx_to_str = ["<", ">"]

# Variables
code_str = ""  # code string
tgt_str = ""  # target sequence
# store the effective values for target.
var_dict = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0}
assigned_var_idx = []
num_assigned_var = 0


# Get number of characters in the string w/o spaces
# NB: line break '\n' counts as one character.
def num_token(string):
    return len(string.split())


# Draw a statement which is not conditional.
# used by get_data_pair below
def draw_non_conditional(apply_op=False):
    global assigned_var_idx, num_assigned_var
    global var_dict, tgt_str, code_str
    op = drw(num_ops - 1)  # cond case removed.
    if op == 0:  # assign
        var_idx = drw(max_num_vars)
        value = drw(max_assign_value)
        if apply_op and var_idx not in assigned_var_idx:
            assigned_var_idx.append(var_idx)
            var_dict[var_idx] = value
            num_assigned_var += 1
            assert num_assigned_var <= max_num_vars
        op_str = f"{var_idx_to_str[var_idx]} = {value} ; "
        code_str += op_str
        tgt_str += f"{no_op_token} " * num_token(op_str)

    if op == 1:  # increment/decrement
        # we can only apply the op to an already defined variable.
        var_idx = assigned_var_idx[drw(num_assigned_var)]
        increment = 1 - drw(2)
        if increment:
            if var_dict[var_idx] + 1 <= max_allowed_val:  # allowed op
                op_str = "++"
                if apply_op:
                    var_dict[var_idx] += 1
            else:  # decrement instead.
                op_str = "--"
                if apply_op:
                    var_dict[var_idx] -= 1
        else:
            if var_dict[var_idx] - 1 >= min_allowed_val:  # allowed op
                op_str = "--"
                if apply_op:
                    var_dict[var_idx] -= 1
            else:  # increment instead.
                op_str = "++"
                if apply_op:
                    var_dict[var_idx] += 1
        op_str = f"{var_idx_to_str[var_idx]} {op_str} ; "
        code_str += op_str
        tgt_str += f"{no_op_token} " * num_token(op_str)

    if op == 2:  # print
        # we can only apply the op to an already defined variable.
        var_idx = assigned_var_idx[drw(num_assigned_var)]
        code_str += f"print {var_idx_to_str[var_idx]} ; "

        # 8 for "print(x)", then the number is the target for the input ";"
        tgt_str += f"{no_op_token} " * 2
        if apply_op:
            tgt_str += f"{var_dict[var_idx]} "
        else:
            tgt_str += f"{no_op_token} "


# Generate one example.
def get_data_pair(code_length):
    '''Get one example of input/output pair.'''

    global assigned_var_idx, num_assigned_var
    global var_dict, tgt_str, code_str
    for count in range(code_length):
        if count == 0:  # Set the first statement to be an assign op.
            op = 0
        elif count == code_length - 1:  # Set last one to be a print op.
            op = 2
        else:
            op = drw(num_ops)

        if op == 0:  # assign
            var_idx = drw(max_num_vars)
            if var_idx not in assigned_var_idx:
                assigned_var_idx.append(var_idx)
                num_assigned_var += 1
                assert num_assigned_var <= max_num_vars
            value = drw(max_assign_value)
            # apply the op
            var_dict[var_idx] = value
            op_str = f"{var_idx_to_str[var_idx]} = {value} ; "
            code_str += op_str
            tgt_str += f"{no_op_token} " * num_token(op_str)

        if op == 1:  # increment/decrement
            # we can only apply the op to an already defined variable.
            var_idx = assigned_var_idx[drw(num_assigned_var)]
            increment = 1 - drw(2)
            if increment:
                if var_dict[var_idx] + 1 <= max_allowed_val:  # allowed op
                    op_str = "++"
                    var_dict[var_idx] += 1
                else:  # decrement instead.
                    op_str = "--"
                    var_dict[var_idx] -= 1
            else:
                if var_dict[var_idx] - 1 >= min_allowed_val:  # allowed op
                    op_str = "--"
                    var_dict[var_idx] -= 1
                else:  # increment instead.
                    op_str = "++"
                    var_dict[var_idx] += 1

            op_str = f"{var_idx_to_str[var_idx]} {op_str} ; "
            code_str += op_str
            tgt_str += f"{no_op_token} " * num_token(op_str)

        if op == 2:  # print
            # we can only apply the op to an already defined variable.
            var_idx = assigned_var_idx[drw(num_assigned_var)]
            code_str += f"print {var_idx_to_str[var_idx]} ; "

            # 6 for "print(x)", then the value is the target for the input ";"
            tgt_str += f"{no_op_token} " * 2 + f"{var_dict[var_idx]} "

        if op == 3:  # conditional
            cond_idx = drw(2)
            var_idx = assigned_var_idx[drw(num_assigned_var)]
            cond_val = drw(max_cond_value)
            # cond "x > 3"
            # cond_str: "if x > 3:"
            cond = (f"{var_idx_to_str[var_idx]} "
                    f"{cond_idx_to_str[cond_idx]} {cond_val}")
            cond_str = f"if {cond} : "
            code_str += cond_str
            tgt_str += f"{no_op_token} " * num_token(cond_str)
            apply_op = False
            if cond_idx:  # 0: less, 1: greater
                if var_dict[var_idx] > cond_val:
                    apply_op = True
            else:
                if var_dict[var_idx] < cond_val:
                    apply_op = True
            draw_non_conditional(apply_op=apply_op)
            # code_str += "\n"
            # tgt_str += f"{no_op_token} "

    return code_str, tgt_str


# Visualize alignment
def visualize(code_str, tgt_str, show_alignment=True):
    # assert len(code_str.split()) == len(tgt_str.split())

    print("=== Code string ============ ")
    print(code_str)

    print("\n=== Target string ========== ")
    print(tgt_str)

    if show_alignment:
        print("\n=== Alignment ")
        a = code_str.split()
        b = tgt_str.split()
        for i in range(len(a)):
            print(f"{a[i]} -> {b[i]}")
    print("=== END ")


# Reset variables
def reset_all():
    global assigned_var_idx, num_assigned_var
    global var_dict, tgt_str, code_str

    code_str = ""  # code string
    tgt_str = ""  # target sequence

    # store the effective values for target.
    var_dict = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0}

    assigned_var_idx = []
    num_assigned_var = 0


if __name__ == '__main__':

    import argparse
    from tqdm import tqdm

    parser = argparse.ArgumentParser(description='Generate data.')
    parser.add_argument('--dump_dir',
        required=True, help='where to store the data')
    parser.add_argument('--train_size', required=False, default=10000,
        type=int, help='Number of examples in the train set.')
    parser.add_argument('--valid_size', required=False, default=1000,
        type=int, help='Number of examples in the valid set.')
    parser.add_argument('--test_size', required=False, default=1000,
        type=int, help='Number of examples in the test set.')

    parser.add_argument('--code_length', required=False, default=100,
        type=int, help='Number of statements in each example.')
    parser.add_argument('--show_example', required=False, action='store_true',
        help='Only show one example.')

    args = parser.parse_args()

    in_sfx = ".src"
    out_sfx = ".tgt"

    train_file_name = f"train_{max_num_vars}"
    valid_file_name = f"valid_{max_num_vars}"
    test_file_name = f"test_{max_num_vars}"

    tr_src = f"{args.dump_dir}/{train_file_name}{in_sfx}"
    tr_tgt = f"{args.dump_dir}/{train_file_name}{out_sfx}"

    valid_src = f"{args.dump_dir}/{valid_file_name}{in_sfx}"
    valid_tgt = f"{args.dump_dir}/{valid_file_name}{out_sfx}"

    test_src = f"{args.dump_dir}/{test_file_name}{in_sfx}"
    test_tgt = f"{args.dump_dir}/{test_file_name}{out_sfx}"

    if args.show_example:
        code_str, tgt_str = get_data_pair(args.code_length)
        visualize(code_str, tgt_str)
        sys.exit(0)

    # train
    print("Generating train data...")
    with open(tr_src, 'a') as txt_in, open(tr_tgt, 'a') as txt_out:
        for i in tqdm(range(args.train_size)):
            code_str, tgt_str = get_data_pair(args.code_length)
            # input_seq = ' '.join(code_str.split())
            input_seq = code_str
            output_seq = tgt_str
            # visualize(code_str, tgt_str)
            # print(input_seq)
            # print(tgt_str)
            if i != args.train_size - 1:
                txt_in.write(input_seq + '\n')
                txt_out.write(output_seq + '\n')

            reset_all()

    # valid
    print("done.")
    print("Generating valid data...")
    with open(valid_src, 'a') as txt_in, open(valid_tgt, 'a') as txt_out:
        for i in tqdm(range(args.valid_size)):
            code_str, tgt_str = get_data_pair(args.code_length)
            # input_seq = ' '.join(code_str.split())
            input_seq = code_str
            output_seq = tgt_str
            # visualize(code_str, tgt_str)
            # print(input_seq)
            # print(tgt_str)

            if i != args.valid_size - 1:
                txt_in.write(input_seq + '\n')
                txt_out.write(output_seq + '\n')

            reset_all()

    # test
    print("done.")
    print("Generating test data...")
    with open(test_src, 'a') as txt_in, open(test_tgt, 'a') as txt_out:
        for i in tqdm(range(args.test_size)):
            code_str, tgt_str = get_data_pair(args.code_length)
            input_seq = code_str
            # input_seq = ' '.join(code_str.split())
            output_seq = tgt_str
            # visualize(code_str, tgt_str)
            # print(input_seq)
            # print(tgt_str)
            if i != args.test_size - 1:
                txt_in.write(input_seq + '\n')
                txt_out.write(output_seq + '\n')

            reset_all()
